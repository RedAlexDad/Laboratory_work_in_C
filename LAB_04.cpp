// LAB_4.cpp

// Лабораторная работа №4

//4. |  хцчш]!}  |	* |	Обратный  |	Четные - нечет	|	Максимум  |  strcmp

// Подключение директивы препроцессора для математических решений
#define _USE_MATH_DEFINES
#pragma warning(disable : 4996)

// Подключение базовые и математические библиотеки
#include <stdio.h>
//#include <process.h>
#include <stdlib.h> 
#include <math.h>
#include <locale.h>
//#include <iostream>
// Подключение библиотеки для выполнения функции выделения памяти
#include <malloc.h>
// Подключение библиотеки для выполнения функции со строками
#include <string.h>

//#include <cstring>	// Для функции strlen()
//#include <string>	// Для обеспечения доступа к строкам (string)
//#include <istream>	// Для функции и класса getline
//#include <string_view>

#include <time.h>
#include "header.h"

// Основная программа
void lab_04() {
	// Подключение русификации программы
	//system("chcp 1251 > nul");
	setlocale(LC_ALL, "Russian");
	// Устанавливаем типы переменных
	int sw; // -> дл переключателей



	// Устанавливаем точку возврата меню с потерей результата
MENU:;

	// Очистика предыдующих результатов
	system("CLS");

	// Вывод меню

	printf("Контрольные задания: \n\n");
	printf("  1. Создание большой строки ФИО. п.5.1 \n");
	printf("  2. Создание строки ФИО инициалами, п.5.2\n");
	printf("  3. Замена символов, п.5.3\n");
	printf("  4. Ввод и вывод массива строк, п.5.4\n");
	printf("  5. Изменение порядка символов в строке, п.5.5\n");
	printf("  6. Динамические строки, п.5.6\n");

	printf("\nПрограмма с дополнительными требованиями:\n\n");
	printf("  7. Создание функции SubString п.7.1\n");
	printf("  8. Создание функции SwapString для строк равных по длине п.7.2\n");
	printf("  9. Изменение порядка символов в строке п.7.3\n");
	printf("  10. Сортировка массива строк п.7.4\n");
	printf("  11. Минимум и максимум в массиве строк п.7.5\n");
	printf("  12. Замена подстроки в строке п.7.6\n");
	printf("  13. Функция сравнение строк п.7.7\n");
	printf("  14. Создание функции DSwapString для динамических строк п.7.8\n");
	printf("  15. Изучение  библиотечных функций. п.7.9\n");


	printf("\n0. Выход ...\n");

	printf("Выберете пункт меню: ");

	//sw = getchar();
	scanf_s("%d", &sw);

	printf("\n");

	//Начало

	// Переключатель
	switch (sw)
	{

	case 1:
	{
		/*Из трех строк, описанных и заранее инициализированных (Name[14], Fam[20], Otch[20]),
		создать новую строку FIO[56], данные разделяются пробелами.
		Массивы символов для строк инициализировать собственными данными студента (ФИО).
		Строку вывести на печать.*/

		system("cls");
		printf("  1. Создание большой строки ФИО. п.5.1 \n");

		char Name[] = { "Алексей" };
		char Fam[] = { "Папин" };
		char Otch[] = { "Владимирович" };

		// Устанавливает длину строка
		char FIO[sizeof(Name) + sizeof(Fam) + sizeof(Otch)];

		//  Копирование и слияние без контроля
		strcpy(FIO, Fam);
		strcat(FIO, " "); //  Нужно для пробела между фамилией и именем
		strcat(FIO, Name);
		strcat(FIO, " "); //  Нужно для пробела между  и именем и отчеством
		strcat(FIO, Otch);
		printf("Фамилия  имя и отчество = %s !\n", FIO);


		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 2:
	{
		/*
		Из трех строк, описанных и введенных заранее с клавиатуры
		(Name[14], Fam[20], Otch[20]), создать новую строку FIO[26],
		в которой имя и отчество задаются инициалами (пер-выми буквами)
		с точками (Например, - Большаков С.А.). В символьные массивы –
		строки инициализировать в программе собственными данными студента (ФИО).
		*/

		system("cls");
		printf("  2. Создание строки ФИО инициалами, п.5.2\n");


		char Name[] = { "Алексей" };
		char Fam[] = { "Папин" };
		char Otch[] = { "Владимирович" };

		// Устанавливает длину строка
		char FIO[sizeof(Name) + sizeof(Fam) + sizeof(Otch)];

		strcpy(FIO, Fam);
		//  Нужно для пробела между фамилией и инициалами
		strcat(FIO, " ");
		// strncat (пустой массив символов, массив символов с заполнением, кол-во заполнений)
		/*
		char * strncat( char * destptr, char * srcptr, size_t num );
		Параметры:
		destptr
		Указатель на строку назначения, которая будет содержать результат конкатенации строк, включая символ завершения строки.

		srcptr
		Cтрока, из которой будут копироваться первые num символов для конкатенации.

		num
		Максимальное количество символов для конкатенации.

		Пусть так:
		FIO = [100];
		Name = "Testirovanie"

		Тогда
		strncat(FIO, Name, 1); ==> FIO = "T"
		strncat(FIO, Name, 5); ==> FIO = "Testi"
		strncat(FIO, Name, 2); ==> FIO = "Te"

		и тд
		*/
		strncat(FIO, Name, 1);
		strcat(FIO, ".");
		strncat(FIO, Otch, 1);
		strcat(FIO, ".");
		printf("Фамилия  имя и отчество = %s !\n", FIO);


		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	//4. |  хцчш]!}  |	*  |  Обратный  |	Четные - нечет	|	Максимум  |  strcmp

	case 3:
	{
		/*5.3. 5.3 Замена символов
		В одномерном символьном массиве (CharMas[40]) все символы из перечня
		(см. таблицу по своему варианту) заменить на один другой символ, заданный вариантом
		(см. ниже). Массив предварительно инициализировать в программе,
		самостоятельно придумав его содержание. Для ветвления в цикле при
		замене символов использовать переключатель (switch).
		Оформить блок-схему программы на MS Visio, как вставленный объект.
		Массив распечатать до и после замены.
		Подсчитать и распечатать число замен (Counter).
		*/
		system("cls");
		printf("3.  Замена символов, п.5.3\n");

		int count = 0;

		char array_char[] = "Сегодня была хорошая погода. Пышные цветы растут часто в лесу!";
		// Определяет размер строка
		int RazmS = strlen(array_char);
		printf("Исходная строка =\n%s !\n", array_char);
		// Цикл замен на пустой символ ' '
		for (int i = 0; i < RazmS; i++)
		{
			switch (array_char[i])
			{
				// хцчш]!}
			case  'х':
			case  'ч':
			case  'ц':
			case  'ш':
			case  ']':
			case  '!':
			case  '}':
				array_char[i] = '*';
				count++;
				break;
			};
		};
		printf("Строка после замены символов \"хцчш]!}\" на пробел\n%s \n", array_char);
		printf("Число замен = %d \n", count);

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 4:
	{
		/*Написать фрагмент программы для ввода с клавиатуры массива строк
		(MasStr – минимум пять строк). Число вводимых строк предварительно
		вводиться с клавиатуры. Распечатать введенный массив строк в столбик
		с указанием номера каждой строки. Порядок вывода строк (прямой или обратный)
		определяется вариантом (см. ниже).
		При выводе массива на экран оформить рамку символом точка (“.”).*/
		system("cls");
		printf("  4. Ввод и вывод массива строк, п.5.4\n");

		int array_string;
		// char ARR_CHAR [Кол-во слов] [Длина строка + \0] = { " " }
		//char test[3][6] = { "Test1", "Test2", "Test3" };

		printf("Введите размер массива строк: \n");
		scanf_s("%d", &array_string);

		// Создание динамической строки 
		// 20 символов -  одна строка
		char* pStrArray = (char*)calloc(array_string, sizeof(char) * 20);
		printf("\nВведите последовательно строки массива строк  [%d] размером не более 20 символов: \n", array_string);

		for (int i = 0; i < array_string; i++)
		{
			char Max[80] = "";
			scanf("%s", Max);
			// Контроль длины введенной строки	     
			if (strlen(Max) > 20)
			{
				printf("Введенная строка превышает размер 20 (%d): \n", strlen(Max));
				i--;
			}
			else
			{
				strcpy(&pStrArray[i * 20], Max);
			}
		}
		printf("\n");
		// Печать массив строк
		printf("Прямой порядок\n");

		for (int i = 0; i < array_string; i++)
			//printf ("Строки массива % d  - %s\n", i , pStrMas + i * 20);
		{
			printf("[ %d ] %10s\n", i, &pStrArray[i * 20]);
		}
		printf("\n\n");
		printf("Обратный порядок\n");
		// Распечатка массива строк в обратном порядке

		for (int i = array_string - 1; i >= 0; i--)
		{
			printf("[ %d ] %10s\n", i, &pStrArray[i * 20]);
		};

		free(pStrArray);

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 5:
	{
		/*Изменить порядок расположения символов в строке (Str5[10]),
		заданной при описании ее в программе с помощью инициализации.
		Порядок замен определяется вариантом. Исходную строку
		и результат изменения распечатать. Строка заканчивается нулевым символом (/0),
		расположение которого не меняется при изменении порядка символов.
		Алгоритм замен нужно уметь продемонстрировать преподавателю в отладчике
		пошаговом режиме.
		Распечатать исходную строку и результат (строку) после изменения порядка.*/
		system("cls");
		printf("  5. Изменение порядка символов в строке, п.5.5\n");

		char array_char[] = "Определение переменной на языке Си. Лекция №1.";
		char cTemp;

		int RazmS = strlen(array_char); // Размер строки - вычисление
		printf("\nИсходная строка =\n%s \n", array_char);
		for (int i = 1; i < RazmS; i++)
		{
			// Обмен символов (Swap) Крайние символы меняются местами
			// Четные - нечет
			if (i % 2 == 1)
			{
				cTemp = array_char[i];
				array_char[i] = array_char[i - 1];
				array_char[i - 1] = cTemp;
			}
		}

		array_char[RazmS] = '\0';
		printf("\n\nРезультирующая строка =\n%s \n", array_char);

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 6:
	{
		/*Описать указатель на строку (pStrD).
		Выделить для этой строки динамическую память в 40 символов.
		Скопировать в эту строку большую строку из п.п. 5.1 (FIO).
		Распечатать исходную строку как массив (в цикле посимвольно!)
		и как динамическую строку через указатель.
		Изменить в данной строке первую букву отчества и снова распечатать.
		Освободить оперативную память, выделенную для динамической строки.*/
		system("cls");
		printf("  6. Динамические строки, п.5.6\n");

		char FIO[56];

		//  Копирование и слияние без контроля
		strcpy(FIO, "Папин ");
		strcat(FIO, "Алексей ");
		strcat(FIO, "Владимирович");

		// 5.6 Указатель на динамическую строку, размер 40 символов
		char* pStrD = (char*)calloc(40, sizeof(char));

		//strcpy(StrPer, "Пример!!!");
		strcpy(pStrD, FIO);
		printf("Динамическая строка = %s !\n", pStrD);
		pStrD[14] = 'К';
		printf("Динамическая строка = %s !\n", pStrD);
		free(pStrD);  // Освобождение ДП под строку


		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	// Дополнительные требования

	case 7:
	{
		/*Спроектировать, реализовать и отладить функцию выбора подстроки из строки.
		В качестве параметров указываются: исходная строка, начальный символ, число символов.
		Предусмотреть вариант функции с 3-мя и 4-мя параметрами
		(Последний задает указатель подстроки).
		предусмотреть полный контроль входных параметров.
		Продемонстрировать ее использование в различных режимах.
		Функцию описать в отдельном заголовочном файле и использовать
		прототип в основной программе.*/
		system("cls");
		printf("  7. Создание функции SubString п.7.1\n");

		char string[100], inital_string[2] = "";
		int count_string;

		scanf("%s", string);

		// 5.6 Указатель на динамическую строку, размер 40 символов
		char* pStrD = (char*)calloc(40, sizeof(char));

		SubString(string, inital_string, &count_string);

		printf(" Строка: %20s \n Первый символ в строке: %s\n Длина символа: %d", string, inital_string, count_string);

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 8:
	{
		/*Спроектировать, реализовать и отладить функцию взаимной замены (Swap) строк.
		В данной функции предположить, что строки имеют одинаковый размер символьных массивов,
		в котором они записаны. Строки не являются динамическими.
		Продемонстрировать ее использование в различных режимах.
		Функцию описать в отдельном заголовочном файле
		и использовать прототип в основной программе.*/
		system("cls");
		printf("  8. Создание функции SwapString для строк равных по длине п.7.2\n");

		char string_1[100] = "", string_2[100] = "";

		printf("Введите любое первое предложение:\n");
		scanf("%s", string_1);
		printf("Введите любое второе предложение:\n");
		scanf("%s", string_2);

		SwapString(string_1, string_2);

		printf("Первое предложение:\n%s\n", string_1);
		printf("Второе предложение:\n%s\n", string_2);

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 9:
	{
		/*Изменить порядок расположения символов в строке (Str5[10]),
		заданной при описании ее в программе с помощью инициализации.
		Порядок замен определяется вариантом. Исходную строку и результат распечатать.
		Строка заканчивается нулевым символом, расположение которого не меняется.
		Алгоритм замен нужно уметь продемонстрировать преподавателю в отладчике п пошаговом режиме.*/
		system("cls");
		printf("  9. Изменение порядка символов в строке п.7.3\n");
		// Обратный порядок изменения строк

		char str5[27] = { "Папин Алексей Владимирович" };
		char tmp;

		printf("\nИсходная строка =\n%s\n", str5);

		for (int i = 0; i < strlen(str5) / 2; i++)
		{
			tmp = str5[i];
			str5[i] = str5[strlen(str5) - i - 1];
			str5[strlen(str5) - i - 1] = tmp;
		}
		str5[strlen(str5)] = '\0';


		printf("\nНовая строка =\n%s\n", str5);

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 10:
	{
		/*Выполнить в двойном цикле сортировку массива строк по возрастанию.
		Массив задается в программе инициализацией при описании.
		Сортировка должна быть выполнена в алфавитном порядке по возрастанию.
		Для оценки возрастания использовать функцию из таблицы вариантов(strlen или strcmp).
		Для сортировки (обмена строк между собой) нужно
		использовать свою функцию SwapString, разработанную выше.
		Массив строк вывести на экран до сортировки и после.*/
		system("cls");
		printf("  10. Сортировка массива строк п.7.4\n");

		//char string[100] = { "Вчера на паре была введена лекция Структура и функция" };
		char string[100] = { "АЮЭЬЫЪЩШЧЦХФУТСЙПОНМЛКРИЗЖЕДГВБЯ" };

		printf("Исходное предложение:\n%s\n", string);
		SwapString_Alphafit(string);
		printf("Новое предложение:\n%s\n", string);
		//printf("Упорядоченный русский алфавит:\nАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ\n");

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 11:
	{
		/*В массиве (MasStr), который был введен в п.п 5.4
		данной ЛР найти минимальную строку и ее номер.
		Результаты распечатать. Критерий “величины” (веса - упорядоченности)
		строки задается вариантом и может быть одним из двух: либо число символов в строке
		(для подсчета использовать функцию strlen) или алфавитный порядок
		(для оценки “величины”  использовать функцию strcmp).
		Значения минимума и его номер распечатать.*/
		system("cls");
		printf("  11. Минимум и максимум в массиве строк п.7.5\n");

		// char ARR_CHAR [Кол-во слов] [Длина строка + \0] = { " " }
		//char test[3][6] = { "Test1", "Test2", "Test3" };

		int size_array_string;
		printf("Введите размер массива строк: \n");
		scanf_s("%d", &size_array_string);

		// Создание динамической строки 2 способа:
		// 1 способ : 20 символов -  одна строка
		//char* pStrArray = (char*)calloc(size_array_string, sizeof(char) * 100);

		// 2 способ : указатели на строку
		char** pStrArray = (char**)calloc(size_array_string, sizeof(char*));
		for (int i = 0; i < size_array_string; i++)
			pStrArray[i] = (char*)calloc(size_array_string, sizeof(char));

		// Ввод строки
		for (int i = 0; i < size_array_string; i++)
		{
			char Max[100] = "";
			scanf("%s", Max);
			strcpy(&pStrArray[i][0], Max);
		}

		// Печать
		for (int i = 0; i < size_array_string; i++)
			printf("[ %d ] : %s\n", i, &pStrArray[i][0]);

		// Сортировка
		for (int i = 0; i < size_array_string - 1; i++)
		{
			for (int j = 0; j < size_array_string - 1; j++)
			{
				// Для убывания по алфавиту
				if (strcmp(&pStrArray[j][0], &pStrArray[j + 1][0]) > 0)
					string_sorting_and_swap(&pStrArray[j][0], &pStrArray[j + 1][0]);
			}
		}

		int max_size = 1000;
		/*
		char** strP = (char**)calloc(size_array_string, sizeof(char*));

		for (int i = 0; i < size_array_string - 1; i++)
		{
			strP[i] = &pStrArray[i][0];
			if (strlen(strP[i]) > strlen(strP[i + 1]))
			{
				printf("&pStrArray[%d][0] > strlen(&pStrArray[%d + 1][0]\n %20s > %20s", i, i, strlen(&pStrArray[i][0]), strlen(&pStrArray[i + 1][0]));
				max_size = strlen(&pStrArray[i][0]);
			}
		}
		*/


		printf("\n Отсортированная строка \n\n");

		// Печать
		for (int i = 0; i < size_array_string; i++)
			printf("[ %d ] : %s\n", i, &pStrArray[i][0]);

		int  MIN_NUM;
		char* MIN_STR = (char*)calloc(max_size, sizeof(char));
		/*
		for (int i = 0; i < size_array_string; i++)
		{
			MIN_NUM = strlen(&pStrArray[i][0]);
			// Нахождение минимальной длины строки
			//minimum_strlen(&pStrArray[i][0], &MIN_NUM, MIN_STR);
			for (int j = 1; j < MIN_NUM; j++)
				if (strlen(&pStrArray[j][0]) < MIN_NUM)
				{
					MIN_NUM = strlen(&pStrArray[j][0]);
					strcpy(MIN_STR, &pStrArray[j][0]);
				}
		}
		*/
		minimum_strlen(pStrArray, &MIN_NUM, MIN_STR);

		printf("Минимальная длина строки : %s\nДлина = %d\n", MIN_STR, MIN_NUM);


		free(pStrArray);
		free(MIN_STR);

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 12:
	{
		/*Спроектировать, реализовать и отладить функцию
		замены одной подстроки другой подстрокой в большой строке.
		Например, по всей строке одна фамилия заменяется на другую фамилию.
		Использовать библиотечные функции для работы со строками.
		Продемонстрировать ее использование в различных режимах.
		Функцию описать в отдельном модуле *.cpp и использовать прототип в основной программе.*/
		system("cls");
		printf("  12. Замена подстроки в строке п.7.6\n");
		//char * strtok( char * string, const char * delim );

		char string[] = "Последовательность вызовов этой функции разбивают строку string на лексемы, которые представляют собой последовательности символов, разделенных символами разделителями.\n";

		string_strtok(string);

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 13:
	{
		/*Спроектировать, реализовать и отладить функцию сравнения строк, аналогичную strncmp.
		Продемонстрировать ее использование в различных режимах.  */
		system("cls");
		printf("  13. Функция сравнение строк п.7.7\n");

		int size_array_string;

		printf("Введите размер массив строк: ");
		scanf_s("%d", &size_array_string);

		char** pStrArray = (char**)calloc(size_array_string, sizeof(char*));
		for (int i = 0; i < size_array_string; i++)
			pStrArray[i] = (char*)calloc(size_array_string, sizeof(char));

		for (int i = 0; i < size_array_string; i++)
		{
			char Max[100] = "";
			scanf("%s", Max);
			strcpy(&pStrArray[i][0], Max);
		}

		printf("\n\n");

		for (int i = 0; i < size_array_string; i++)
			printf("№%d слово: %s\n", i, &pStrArray[i][0]);

		printf("\n");
		check_strncmp(pStrArray, size_array_string);

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 14:
	{
		/*Спроектировать, реализовать и отладить функцию взаимной замены (Swap) строк.
		Строки могут быть разной длинны. Строки являются динамическими,
		то есть под них выделена динамическая память.
		Использовать функции malloc и free для работы с динамической памятью.
		Продемонстрировать использование функции в различных режимах.
		Функцию описать в отдельном заголовочном файле и использовать прототип в основной программе.*/
		system("cls");
		printf("  14. Создание функции DSwapString для динамических строк п.7.8\n");

		int size_array_string;

		printf("Введите размер массив строк: ");
		scanf_s("%d", &size_array_string);

		char** pStrArray = (char**)malloc(size_array_string * sizeof(char*));
		for (int i = 0; i < size_array_string; i++)
			pStrArray[i] = (char*)malloc(size_array_string * sizeof(char));

		for (int i = 0; i < size_array_string; i++)
		{
			char Max[100] = "";
			scanf("%s", Max);
			strcpy(&pStrArray[i][0], Max);
		}

		//printf("\n\n");

		for (int i = 0; i < size_array_string; i++)
			printf("№%d слово: %s\n", i, &pStrArray[i][0]);

		DSwapString(pStrArray, size_array_string);
		printf("\n");

		for (int i = 0; i < size_array_string; i++)
			printf("NEW №%d слово: %s\n", i, &pStrArray[i][0]);

		free(pStrArray);

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 15:
	{
		/*Изучить библиотечные функции: strftime, strrchr и _fcvt.
		Познакомиться с документацией, привести примеры использования данных функций.
		Познакомиться с библиотеками: string.h, malloc.h и stdlib.h.
		Для этого помимо документации можно прочитать эти заголовочные файлы.*/
		system("cls");
		printf("  15. Изучение  библиотечных функций. п.7.9\n");

		//strftime - Получение форматированной строки с датой и временем.
		/*
		size_t strftime( char * stringptr, size_t maxnum, const char * strformat, const struct tm * timeptr );

		Синтаксис:

			import time
			time.strftime(format[, t])

		Параметры:

			stringptr
				Указатель на массив назначения, где в результате будет храниться
				скопированная Си-строка.

			maxnum
				Максимальное количество символов для копирования в stringptr.

			strformat
				Cи-строка, содержащая любую комбинацию из обычных символов и
				специальных спецификаторов формата.
				Эти спецификаторы формата заменяются на соответствующие
				значения даты и времени, указанных в timeptr.
				Все спецификаторы начинаются с процента %.

		Список спецификаторов формата показан ниже, в таблице:
		%a	Сокращенное название дня недели.
		%A	Полное название дня недели.
		%b	Сокращенное название месяца в локали.
		%B	Полное название месяца в локали.
		%c	Соответствующая локали дата и время.
		%d	День месяца в виде десятичного числа [01,31].
		%H	Час (24-часовой формат) в виде десятичного числа [00,23].
		%I	Час (12-часовой формат) в виде десятичного числа [01,12].
		%j	День года в виде десятичного числа [001,366].
		%m	Месяц как десятичное число [01,12].
		%M	Минута в виде десятичного числа [00,59].
		%p	Либо AM, либо PM в 12-часовом формате.	(1)
		%S	Секунды как десятичное число [00,61].	(2)
		%U	Номер недели в году (воскресенье - первый день недели) в виде десятичного числа [00,53]. Все дни в новом году, предшествующем первому воскресенью, считаются на неделе 0.	(3)
		%w	День недели в виде десятичного числа [0 - воскресенье, 6].
		%W	Номер недели в году (понедельник - первый день недели) в виде десятичного числа [00,53]. Все дни в новом году, предшествующем первому понедельнику, считаются на неделе 0.	(3)
		%x	Соответствующее представление даты локали.
		%X	Соответствующее время локали.
		%y	Год без века как десятичное число [00,99].
		%Y	Год с веком как десятичное число.
		%z	Смещение часового пояса, указывающее положительную или отрицательную разницу во времени относительно времени UTC/GMT в формате +ЧЧММ или -ЧЧММ, где Ч представляет цифры часа, а М представляет цифры минуты [-23:59, +23:59].
		%Z	Название часового пояса (без символов, если часовой пояс не существует).
		%%	Буквальный символ '%'.

		*/
		//Примеры использования:
		//	Формат даты, указанным в стандарте электронной почты RFC 2822.
		printf("Strftime\n");

		time_t rawtime;
		struct tm* timeinfo;
		// строка, в которой будет храниться текущее время
		char buffer[80];

		// текущая дата в секундах
		time(&rawtime);
		// текущее локальное время, представленное в структуре
		timeinfo = localtime(&rawtime);

		// форматируем строку времени
		strftime(buffer, 80, "Сейчас %I:%M%p.", timeinfo);
		printf("%s\n", buffer);

		printf("\n");
		//char* strrchr(const char* string, int symbol);
		/*

		Параметры:

			string
				Строка, в которой выполняется поиск.
			symbol
				Искомый символ. Передается функции как целое число, после конвертируется в char.

		Возвращаемое значение

			Указатель на последнее вхождение символа в строку string.
			Если значение не найдено, функция возвращает нулевой указатель.

			Пример:
		*/

		printf("Strrchr\n");
		char str[] = "Автономная Республика Крым";
		char* pch = strrchr(str, 'м');
		printf("Автономная Республика Крым\n");
		// Адрес pch - адрес str + 1 байт = Адрес позиции
		int addres = pch - str + 1;
		printf("Последнее вхождение символа 'м' - %d позиция\n", addres);

		// char *fcvt(double value, int ndigit, int *dec, int sign)
		/*
		Описание:
			Эта функция не определена стандартом ANSI C.

		Функция fcvt() та же самая, что и функция ecvt(), за исключением того,
		что выходные данные округляются до числа цифр, заданных параметром ndigit.
		Функция fcvt() возвращает указатель на статическую область данных,
		которая содержит строку, представляющую число.

		char *ecvt(double value, int ndigit, int *dec, int sign)

		Описание:
			Эта функция не определена стандартом ANSI С.

		Функция ecvt() конвертирует параметр value в строку длиной ndigit.
		После вызова величина переменной, на которую указывает dec,
		отвечает положению десятичной точки.
		Если десятичная точка находится слева от числа, то число,
		на которое указывает dec, является отрицательным.
		Десятичная точка не хранится в строке.
		Если параметр value положительный, то знак sign равен 0.
		Если число отрицательно, то параметр sign ненулевой.

		Функция ecvt() возвращает указатель на статическую область данных,
		которая содержит строку, представляющую число.

		Пример:
		*/
		printf("Fcvt\n");
		//Следующий вызов функции конвертирует число 10.12 в строку :
		int decpnt, sign;
		char* out;
		out = fcvt(10.12, 5, &decpnt, &sign);

		out = ecvt(10.12, 5, &decpnt, &sign);

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 0:
	{
		printf("Выход с программы\n\n");

		// После этого пункта выход из программы
		exit(0);
	}

	default:
	{
		printf("Данный символ не опознан. Возврат в меню\n");

		// Сброс буферизации при нажатии ENTER
		sw = getchar();

		system("pause");
		goto MENU;
		break;
	}
	}

	system("PAUSE");
}

