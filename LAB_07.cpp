// Лабораторная работа №7

// Подключение директивы препроцессора для математических решений
#define _USE_MATH_DEFINES
#pragma warning(disable : 4996)
//#pragma warning(disable : 4700)

// Подключение базовые и математические библиотеки
#include <stdio.h>
#include <process.h>
#include <stdlib.h> 
#include <math.h>
#include <locale.h>
// Подключение библиотеки для выполнения функции выделения памяти
#include <malloc.h>
// Подключение библиотеки для выполнения функции со строками
#include <string.h>
// Подключение библиотеки для низкоуровенных языках
#include <io.h>

#include "header.h"

// Основная программа
void lab_07() {
	// Подключение русификации программы
	//system("chcp 1251 > nul");
	setlocale(LC_ALL, "Russian");
	// Устанавливаем типы переменных
	int sw; // -> дл переключателей



	// Устанавливаем точку возврата меню с потерей результата
MENU:;

	// Очистика предыдующих результатов
	system("CLS");

	// Вывод меню

	printf("Контрольные задания: \n\n");
	printf("  1. Создание консольного проекта ЛР, п.5.1 \n");
	printf("  2. Запись простого файла текстовыми данными,  его чтение и распечатка, п.5.2\n");
	printf("  3. Создать функцию распечатки текстового файла по строкам , п.5.3\n");
	printf("  4. Написать фрагмент программы для записи в файл своих структур, п.5.4\n");
	printf("  5. Написать фрагмент программы для распечатки файла своих структур, п.5.5\n");
	printf("  6. Создать функцию распечатки файла своих структур, п.5.6\n");
	printf("  7. Написать фрагмент программы для записи файла на основе массива структур, п.5.7\n");
	printf("  8. Создать функцию записи в файл на основе массива своих структур, п.5.8\n");
	printf("  9. Написать фрагмент программы  записи в массив своих структур из файла, п.5.7\n");
	printf("  10. Создать функцию записи из файла в массив своих структур, п.5.7\n");
	printf("  11. Создать функцию распечатки массива своих структур, п.5.7\n");
	printf("  12. Написать фрагмент программы для слияния 2-х файлов в общий файл, п.5.7\n");

	/*
	printf("\nПрограмма с дополнительными требованиями:\n\n");
	printf("  -13. Запись двоичного файла случайными данными и его чтение , п.7.1\n");
	printf("  -14. Поиск минимума в файле по числовому полю, п.7.2\n");
	printf("  -15. Создать функцию копирования текстовых файлов, п.7.3\n");
	printf("  -16. Поиск заданного текста в строках текстового файла, п.7.4\n");
	printf("  -17. Слияние 2-х двоичных файлов в третий, п.7.5\n");
	printf("  -18. Программа печати файлов на основе списка, заданного в другом файле, п.7.6\n");
	printf("  -19. Функция чтения файла в список структур, п.7.7\n");
	printf("  -20. Функция записи файла из списка структур, п.7.8\n");
	printf("  -21. Поиск заданного текста или целого числа в полях записи двоичного файла, п.7.9\n");
	*/


	printf("\n0. Выход ...\n");

	printf("Выберете пункт меню: ");

	//sw = getchar();
	scanf_s("%d", &sw);

	printf("\n");

	//Начало

	// Переключатель
	switch (sw)
	{

	case 1:
	{
		/*Создать пустой консольный проект для выполнения ЛР № 6.
		Пример создания консоль-ного проекта и его русификация рассмотрено в методических указаниях к ЛР №1
		по дисциплине ОП (см. на сайте). В проект обязательно включить три модуля:
		first.cpp (для главной программы проекта),
		second.cpp (для размещения функций проекта) и
		header.h (для описаний структур и прототипов функций проекта).*/

		system("cls");
		printf("  1. Создание консольного проекта ЛР, п.5.1 \n");

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 2:
	{
		/*Создать и заполнить в цикле текстовый файл из массива строк.
		Массив инициализирует-ся строками с фамилиями студентов вашей группы.
		После создания файл (а не массив!) прочи-тать и распечатать.
		Продемонстрировать преподавателю содержание файла с использованием файл менеджера (можно Far).
		(см. п.п. 4.2/4.3 данного МУ)*/

		system("cls");
		printf("  2. Запись простого файла текстовыми данными,  его чтение и распечатка, п.5.2\n");

		char Array_FIO[8][20] =
		{
			{"Папин_Алексей"}, {"Малахов_Владислав"},
			{"Перевощиков_Никита"}, {"Смирнов_Даниил"},
			{"Клеша_Егор"}, {"Печуркин_Дмитрий"},
			{"Афанасьев_Даниил"}, {"..._..."}
		};

		FILE* data_fio;

		// Открытие файла для записи
		data_fio = fopen("file52.out", "w+");


		for (int i = 0; i < 8; i++)
			fprintf(data_fio, "%s\n", &Array_FIO[i][0]);

		// Закрывает и завершает работу файла
		fclose(data_fio);

		//system("type file52.out");

		// Буфер для ввода из файла
		char buff_fio[80];
		FILE* p_FILE;

		p_FILE = fopen("file52.out", "r+");
		for (int i = 0; !feof(p_FILE); i++)
		{
			// Ввод форматированных данных - разделитель if (  !feof(pF) )
			fscanf(p_FILE, "%s", buff_fio);
			printf("%s\n", buff_fio);
		}

		// Печать данных из файла  в окно консоли
		fclose(p_FILE);


		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 3:
	{
		/*Сделать и проверить функцию (PrintTextFile) распечатки текстового файла по строкам.
		Проверить ее по шагам в отладчике.
		В качестве параметра для распечатки передается указатель на строку – имя файла.
		Распечатать файл предыдущего задания этой функцией. */

		system("cls");
		printf("  3. Создать функцию распечатки текстового файла по строкам , п.5.3\n");

		char Array_FIO[8][20] =
		{
			{"Папин_Алексей"}, {"Малахов_Владислав"},
			{"Перевощиков_Никита"}, {"Смирнов_Даниил"},
			{"Клеша_Егор"}, {"Печуркин_Дмитрий"},
			{"Афанасьев_Даниил"}, {"..._..."}
		};

		FILE* data_fio;

		// Открытие файла для записи
		data_fio = fopen("file52.out", "w+");


		for (int i = 0; i < 8; i++)
			fprintf(data_fio, "%s\n", &Array_FIO[i][0]);

		// Закрывает и завершает работу файла
		fclose(data_fio);

		printf_text_from_file("file52.out");

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 4:
	{
		/*Написать фрагмент программы  для записи своих структурных переменных
		(ЛР № 6  и таблицу вариантов) в двоичный файл.
		Придумать свое уникальное название файла и его расширение.
		Для заполнения файла использовать массив  структурных переменных,
		который проини-циализирован в программе. Размер массива не более трех.
		Для записи в файл использовать функцию fwrite.
		Проверить заполнение файла в файловом менеджере.
		Пусть наша Student структура имеет вид (ее нужно поместить в заголовочный файл header.h ):*/

		system("cls");
		printf("  4. Написать фрагмент программы для записи в файл своих структур, п.5.4\n");

		Vehicles Cars[2] =
		{
			{"Копейка" , "ВАЗ-2101", "Седан" , 2002, 30000},
			{"Лада" , "ВАЗ-2111", "Внедорожник" , 2022, 35000},
		};

		// Открытие файла для записи
		FILE* file_first = fopen("BD_Vehicles.bin", "wb");

		// Размер массива для цикла
		int Razm = sizeof(Cars) / sizeof(Vehicles);
		for (int i = 0; i < Razm; i++)
			fwrite(Cars + i, sizeof(Vehicles), 1, file_first);

		fclose(file_first);



		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 5:
	{
		/*Написать фрагмент программы для чтения и распечатки файла своих структур.
		Конец файла проверять функцией feof. Можно использовать функцию печати одной структуры из ЛР №6.
		Распечатать в цикле файл структур из предыдущего задания. (см. п.п. 4.5 данного МУ).*/

		system("cls");
		printf("  5. Написать фрагмент программы для распечатки файла своих структур, п.5.5\n");

		Vehicles Cars[2] =
		{
			{"Копейка" , "ВАЗ-2101", "Седан" , 2002, 30000},
			{"Лада" , "ВАЗ-2111", "Внедорожник" , 2022, 35000},
		};

		// Открытие файла для записи
		FILE* file_first = fopen("BD_Vehicles.bin", "wb");

		// Размер массива для цикла -> Размер всего массива в байтах и поделить на структуру = кол-во массив структур
		int size = sizeof(Cars) / sizeof(Vehicles);

		for (int i = 0; i < size; i++)
			fwrite(Cars + i, sizeof(Vehicles), 1, file_first);

		fclose(file_first);


		file_first = fopen("BD_Vehicles.bin", "rb");

		if (file_first != NULL)
			// Цикл чтения и распечатки файла своих структур:
			// Функция feof проверяет, достигнут ли конец файла, связанного с потоком, через параметр filestream.
			// Если возвращает 0, то файл достигнут конец
			while (!feof(file_first))  // Проверка конца файла
			{
				fread(&Cars, sizeof(Vehicles), 1, file_first); // Чтение одной записи из файла
				if (!feof(file_first)) // Можно ли печатать? Нет ли уже конца файла?
				{
					printf("Марка: %20s \n", Cars->Marka_car);
					printf("Модель: %19s\n", Cars->Model_car);
					printf("Тип кузова: %15s \n", Cars->Corpuse);
					printf("Год выпуска: %11d г.\n", Cars->Date_year);
					printf("Стоимость: %9d Рублей\n", Cars->Price);
					printf("\n");
				}
			}

		fclose(file_first);

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 6:
	{
		/*Написать функцию для распечатки файла своих структур, основываясь на
		примере предыдущего пункта задания. В функцию передается только имя файла в виде указателя на строку..
		Проверить использование данной функции на файле своих структур. (см. п.п. 4.8 дан-ного МУ).*/

		system("cls");
		printf("  6. Создать функцию распечатки файла своих структур, п.5.6\n");

		Vehicles Cars[2] =
		{
			{"Копейка" , "ВАЗ-2101", "Седан" , 2002, 30000},
			{"Лада" , "ВАЗ-2111", "Внедорожник" , 2022, 35000},
		};

		// Открытие файла для записи
		FILE* file_first = fopen("BD_Vehicles.bin", "wb");

		// Размер массива для цикла
		int Razm = sizeof(Cars) / sizeof(Vehicles);
		for (int i = 0; i < Razm; i++)
			fwrite(Cars + i, sizeof(Vehicles), 1, file_first);

		fclose(file_first);

		// Функция печати файла содержащиеся структуры
		for (int i = 0; i < 1; i++)
			printf_text_struct_from_file("BD_Vehicles.bin");



		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 7:
	{
		/*Написать фрагмент программы для записи файла своих структур на основе массива сво-их структур.
		Построить цикл записи. Число записей в массиве вычислять с помощью функции  sizeof.
		Можно использовать функцию печати одной структуры из ЛР №6. Массив инициализируется в программе.
		Распечатать полученный файл с помощью функции предыдущего п.п.  (см. п.п. 4.5 данного МУ).*/

		system("cls");
		printf("  7. Написать фрагмент программы для записи файла на основе массива структур, п.5.7\n");

		Vehicles Cars[] =
		{
			{"Копейка" , "ВАЗ-2101", "Седан" , 2002, 30000},
			{"Лада" , "ВАЗ-2111", "Внедорожник" , 2022, 35000},
			{"Жигуль" , "ВАЗ-2112", "Универсал" , 2022, 35000},
			{"Икарус" , "И-223", "Кабриолет" , 2022, 100}
		};

		// Открытие файла для записи
		//FILE* file_first = fopen("BD_Vehicles.bin", "wb");

		// Размер массива для цикла
		int size = sizeof(Cars) / sizeof(Vehicles);

		// Вызов функции для чтении и записи файла
		read_and_input_text_struct_into_file("BD_Vehicles.bin", Cars, size);
		// Вызов функции для печати файла
		//printf_text_struct_from_file("BD_Vehicles.bin");

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 8:
	{
		/*Написать функцию для записи структурных переменных из массива в файл.
		Имя файла и массив передается в функцию в качестве параметров (указатели).
		Использовать примеры, рас-смотренные выше.
		Проверить ее использование. (см. п 4.5 данного МУ)*/

		system("cls");
		printf("  8. Создать функцию записи в файл на основе массива своих структур, п.5.8\n");

		Vehicles Cars[] =
		{
			{"Копейка" , "ВАЗ-2101", "Седан" , 2002, 30000},
			{"Лада" , "ВАЗ-2111", "Внедорожник" , 2022, 35000},
			{"Жигуль" , "ВАЗ-2112", "Универсал" , 2022, 35000},
			{"Икарус" , "И-223", "Кабриолет" , 2022, 100}
		};

		// Открытие файла для записи
		//FILE* file_first = fopen("BD_Vehicles.bin", "wb");

		// Размер массива для цикла
		int size = sizeof(Cars) / sizeof(Vehicles);

		// Вызов функции для чтении и записи файла
		read_and_input_text_struct_into_file("BD_Vehicles.bin", Cars, size);
		// Вызов функции для печати файла
		printf_text_struct_from_file("BD_Vehicles.bin");


		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;

	}

	case 9:
	{
		/*Написать фрагмент программы  для записи в массив своих структур  информации из файла.
		Для массива выделить динамическую память на основе вычисления числа записей в файле
		(функция filelength).   Использовать примеры, рассмотренные выше.
		Массив распечатать. По-сле распечатки массив удалить.(см. п 4.6 данного МУ)*/

		system("cls");
		printf("  9. Написать фрагмент программы  записи в массив своих структур из файла, п.5.7\n");

		Vehicles Cars[] =
		{
			{"Копейка" , "ВАЗ-2101", "Седан" , 2002, 30000},
			{"Лада" , "ВАЗ-2111", "Внедорожник" , 2022, 35000},
			{"Жигуль" , "ВАЗ-2112", "Универсал" , 2022, 35000},
			{"Икарус" , "И-223", "Кабриолет" , 2022, 100}
		};

		FILE* pF001 = fopen("BD_Vehicles.bin", "r"); // Открытие файла для чтения

		int size = sizeof(Cars) / sizeof(Vehicles);

		// Вызов функции для чтении и записи файла
		read_and_input_text_struct_into_file("BD_Vehicles.bin", Cars, size);

		printf_text_struct_from_file("BD_Vehicles.bin");


		if (pF001 != NULL)
		{
			//int num = _fileno(pF001);
			// Размер массива
			long size_file = _filelength(_fileno(pF001)) / sizeof(Vehicles);

			Vehicles* pWorkMas = (Vehicles*)calloc(size_file, sizeof(Vehicles));
			for (int i = 0; i < size_file; i++)
				fread(pWorkMas + i, sizeof(Vehicles), 1, pF001);
		}
		fclose(pF001);

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 10:
	{
		/*Написать функцию для записи массива структур из файла.
		Динамическая память выделя-ется в функции. Функция возвращает указатель на массив.
		Использовать примеры, рассмотрен-ные выше.
		Проверить ее использование. (см. п.п. 4.6, 4.7 данного МУ)*/

		system("cls");
		printf("  10. Создать функцию записи из файла в массив своих структур, п.5.7\n");


		Vehicles Cars[] =
		{
			{"Копейка" , "ВАЗ-2101", "Седан" , 2002, 30000},
			{"Лада" , "ВАЗ-2111", "Внедорожник" , 2022, 35000},
			{"Жигуль" , "ВАЗ-2112", "Универсал" , 2022, 35000},
			{"Икарус" , "И-10000", "Кабриолет" , 2022, 100}
		};

		FILE* pF001 = fopen("BD_Vehicles.bin", "r"); // Открытие файла для чтения

		int size = sizeof(Cars) / sizeof(Vehicles);

		// Вызов функции для чтении и записи файла
		read_and_input_text_struct_into_file("BD_Vehicles.bin", Cars, size);

		//printf_text_struct_from_file("BD_Vehicles.bin");

		Vehicles* New_Cars;

		// Вызов функции
		vechicles_read_file_into_struct("BD_Vehicles.bin", &New_Cars, &size);

		printf("Печать новой структуры\n");
		for (int i = 0; i < size; i++)
			Print_Vehicles(New_Cars[i]);

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;

	}

	case 11:
	{
		/*Написать функцию для распечатки массива своих структур.
		В функцию передается  ука-затель на массив и его размер.
		Использовать примеры, рассмотренные выше. Проверить ее использование.
		Использовать функцию для распечатки массива, полученного на основе файла в предыдущем п.п.(см. п.п. 4.7 данного МУ)*/
		system("cls");
		printf("  11. Создать функцию распечатки массива своих структур, п.5.7\n");

		Vehicles Cars[] =
		{
			{"Копейка" , "ВАЗ-2101", "Седан" , 2002, 30000},
			{"Лада" , "ВАЗ-2111", "Внедорожник" , 2022, 35000},
			{"Жигуль" , "ВАЗ-2112", "Универсал" , 2022, 35000},
			{"Икарус" , "И-223", "Кабриолет" , 2022, 100}
		};

		vechicles_print_array(Cars, sizeof(Cars) / sizeof(Vehicles));

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 12:
	{
		/*Сделать программу для слияния двух текстовых/двоичных файлов (по варианту).
		Файлы уже сформированы и их имена задаются в программе.
		Третий файл называется: result.txt.
		Типы файлов: текстовый или двоичный задается вариантом.
		Исходные файлы и результирующий файл распечатать своей функцией (PrintTextFile/ типа StudPrintMas).
		Если исходные файлы не найдены (ошибка открытия), то выдать сообщение об ошибке.
		Можно оформить в виде функ-ции, как в примере.*/

		// Тип файлов для слияния в (для функции слияния) Двоичный
		// "wb"- открыть или создать бинарный файл для чтения и записи, для созданных файлов содержимое очищается. 

		system("cls");
		printf("  12. Написать фрагмент программы для слияния 2-х файлов в общий файл, п.5.7\n");


		Vehicles First_car[] =
		{
			{"Копейка" , "ВАЗ-2101", "Седан" , 2002, 30000},
			{"Лада", "ВАЗ-2111", "Внедорожник", 2022, 35000}
		};

		Vehicles Second_car[] =
		{
			{ "Жигуль" , "ВАЗ-2112", "Универсал" , 2022, 35000 },
			{ "Икарус" , "И-223", "Кабриолет" , 2022, 100 }
		};

		// Открытие файла для чтения
		FILE* pF001 = fopen("First_car.bin", "r");
		FILE* pF002 = fopen("Second_car.bin", "r");
		FILE* pF_merge = fopen("Merge_car.bin", "r");

		int size_1 = sizeof(First_car) / sizeof(Vehicles);
		int size_2 = sizeof(Second_car) / sizeof(Vehicles);

		// Вызов функции для чтении и записи файла
		read_and_input_text_struct_into_file("First_car.bin", First_car, size_1);
		read_and_input_text_struct_into_file("Second_car.bin", Second_car, size_2);

		// Вызов функции для слиянии двух файл
		vehicles_merge_files("Merge_car.bin", "First_car.bin", "Second_car.bin");

		// Печать на экран слиянный файл
		printf_text_struct_from_file("Merge_car.bin");

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	// Дополнительные требования

	case 13:
	{
		/*Для своей структуры по варианту создается двоичный файл и заполняется данными.
		Одно из полей записи должно формироваться датчиком случайных чисел (функция rand).
		Символьное поле заполняется из массива строк значениями, осмысленными для своей структуры.
		Число генерируемых записей задается по варианту: фиксировано (целая константа),
		переменная этапа компиляции (#define) или константная переменная (const int).
		После заполнения файл распеча-тать. Для решения задачи использовать
		пример из теоретической части данных методических указания
		(раздел “ Работа с текстовым файлом построчно ”).
		Файл распечатать на основе сво-ей функции.*/

		system("cls");
		printf("  13. Запись двоичного файла случайными данными и его чтение , п.7.1\n");



		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 14:
	{
		/*В своем файле из записей структурных переменных найти запись с минимальным значе-нием.
		Тип поля взять из списка вариантов. */

		system("cls");
		printf("  14. Поиск минимума в файле по числовому полю, п.7.2\n");


		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 15:
	{
		/*Сделать программу для копирования текстового файла в другой текстовый файл.
		Про-грамму копирования оформить в виде функции (CopyFile).
		После копирования распечатать файлы с помощью своей функции PrintTextFile.*/

		system("cls");
		printf("  15. Создать функцию копирования текстовых файлов, п.7.3\n");



		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 16:
	{
		/*В двоичном файле, созданном ранее, выполняется поиск осмысленного символьного значения.
		При этом записи последовательно считываются из файла и сравниваются с искомым эталоном.
		Напечатать запись и ее номер в файле.*/

		system("cls");
		printf("  16. Поиск заданного текста в строках текстового файла, п.7.4\n");


		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 17:
	{
		/*Оба файла считываются в память едиными фрагментами, сливаются в единый фрагмент,
		а затем целиком копируются в новый файл.
		Имена файлов заданы в аргументах командной строки (аргументы main).*/

		system("cls");
		printf("  17. Слияние 2-х двоичных файлов в третий, п.7.5\n");



		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 18:
	{
		/*Распечатывается список файлов, перечень которых задан в отдельном текстовом файле.
		Имя этого файла задано аргументом командной строки (аргументы main). */

		system("cls");
		printf("  18. Программа печати файлов на основе списка, заданного в другом файле, п.7.6\n");



		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 19:
	{
		/*Свой файл, со своей структурой по варианту,
		считывается в список с динамическим добавлением элементов списка.
		Результат чтения распечатывается из списка.*/

		system("cls");
		printf("  19. Функция чтения файла в список структур, п.7.7\n");



		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;

	}

	case 20:
	{
		/**/

		system("cls");
		printf("  20. Функция записи файла из списка структур, п.7.8\n");



		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 21:
	{


		system("cls");
		printf("  21. Поиск заданного текста или целого числа в полях записи двоичного файла, п.7.9\n");



		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 0:
	{
		printf("Выход с программы\n\n");

		// После этого пункта выход из программы
		exit(0);
	}

	default:
	{
		printf("Данный символ не опознан. Возврат в меню\n");

		// Сброс буферизации при нажатии ENTER
		sw = getchar();

		system("pause");
		goto MENU;
		break;
	}

	system("PAUSE");
	}
}