// LAB_6.cpp

// Лабораторная работа №6

// Подключение директивы препроцессора для математических решений
#define _USE_MATH_DEFINES
#pragma warning(disable : 4996)
//#pragma warning(disable : 4700)

// Подключение базовые и математические библиотеки
#include <stdio.h>
#include <process.h>
#include <stdlib.h> 
#include <math.h>
#include <locale.h>
// Подключение библиотеки для выполнения функции выделения памяти
#include <malloc.h>
// Подключение библиотеки для выполнения функции со строками
#include <string.h>

#include "header.h"

// Основная программа
void lab_06() {
	// Подключение русификации программы
	setlocale(LC_ALL, "Russian");
	system("chcp 1251 > nul");
	// Устанавливаем типы переменных
	int sw; // -> дл переключателей



	// Устанавливаем точку возврата меню с потерей результата
MENU:;

	// Очистика предыдующих результатов
	system("CLS");

	// Вывод меню

	printf("Контрольные задания: \n\n");
	printf("  1. Создание консольного проекта ЛР, п.5.1 \n");
	printf("  2. Описать структуру своего варианта ДЗ и работа с ней, п.5.2\n");
	printf("  3. Функция Распечатки структуры, п.5.3\n");
	printf("  4. Функция Распечатки структуры через указатель, п.5.4\n");
	printf("  5. Массив структур, его инициализация и функция распечатки, п.5.5\n");
	printf("  6. Функция копирования структур, п.5.6\n");
	printf("  7. Функция обмена (Swap) для структур, п.5.7\n");
	printf("  8. Использование перечислений по варианту, п.5.8\n");
	printf("  9. Заполнение числовых полей массива структур случайными данными, п.5.7\n");

	printf("\nПрограмма с дополнительными требованиями:\n\n");
	printf("  10. Сортировка массива по целому полю, п.7.1\n");
	printf("  11. Двумерный массив структур, инициализация и распечатка, п.7.2\n");
	printf("  12. Заполнение данных случайными числами в массиве структур, п.7.3\n");
	printf("  13. Поиск экстремума в массиве структур, его номера и  распечатка, п.7.4\n");
	printf("  14. Сортировка массива структур своего варианта ДЗ по символьному параметру, п.7.5\n");
	printf("  15. Сортировка массива указателей на структуры, п.7.6\n");
	printf("  16. Функция для создания и заполнения динамического массива структур, п.7.7\n");
	printf("  17. Функция для корректного удаления динамического массива структур ДЗ, п.7.8\n");
	printf("  18. Swap для структуры с динамическими строками, п.7.9\n");
	printf("  19. Функция ввода структуры, п.7.10\n");
	printf("  20. Функция изменения структуры, п.7.11\n");
	printf("  21. Сортировка массива структур, п.7.12\n");



	printf("\n0. Выход ...\n");

	printf("Выберете пункт меню: ");

	//sw = getchar();
	scanf_s("%d", &sw);

	printf("\n");

	//Начало

	// Переключатель
	switch (sw)
	{

	case 1:
	{
		/*
		Создать пустой консольный проект для выполнения ЛР № 6.
		Пример создания консоль-ного проекта и его русификация рассмотрено в методических
		указаниях к ЛР №1 по дисциплине ОП (см. на сайте).
		В проект обязательно включить три модуля:
		first.cpp (для главной программы проекта),
		second.cpp (для размещения функций проекта),
		header.h (для описаний структур и прототипов функций проекта).
		*/
		system("cls");
		printf("  1. Создание консольного проекта ЛР, п.5.1 \n");

		// Описание переменных и их инициализация:
		Vehicles S1 = { "Копейка" , "ВАЗ-2101", "Седан" , 2002, 30000 };
		printf("Марка: %25s \nМодель: %24s \nТип кузова: %20s \nГод выпуска: %16d г.\nСтоимость: %14.3lf Рублей\n\n", S1.Marka_car, S1.Model_car, S1.Corpuse, S1.Date_year, S1.Price);


		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 2:
	{
		/*
		ВНИМАНИЕ: Все функции, разрабатываемые в задании, в названии должны иметь
		название собственной структуры (у нас Student).
		Например, у нас в примерах: StudentPrint , SwapStudent , StudentArrayPrint и т.д.
		Описать свою структуру (по своему варианту см. таблицу ниже – раздел 6)
		со статиче-скими строками и описать первоначально одну структурную переменную этого типа структур.
		Поля вашей структуры должны быть иметь удобные названия для запоминания и использования.
		Число полей в шаблоне структуры должно быть не менее 5-ти разных полей.
		Три поля должны быть числовыми. Как минимум, одно поле должно быть строкой (массивом типа char).
		Все поля должны быть осмыслены( иметь определенный смысл для вашей структуры).
		Они должны соответствовать предметной области для названия собственной структуры.
		Поля должны иметь разные типы: целое, вещественное и строка (статическая).
		Нужно очень хорошо поду-мать где, в каких задачах может использоваться данная структура в дальнейшем.
		Желательно сформировать список применений в программах данной структуры, опираясь на собственный опыт,
		фантазию. Можно поговорить с другими людьми, студентами, родителями и преподавателями.
		Качество и осмысленность выбранных полей и задач будет отдельно оцениваться.
		Например, для структуры типа студент можно выбрать: фамилия, курс, пол, группа,
		размер стипендии и т.д. Структура может иметь статические строки и строки,
		формируемые в про-грамме динамически  (см. ЛР №4) (поместить в файл header.h проекта):
		*/

		system("cls");
		printf("  2. Описать структуру своего варианта ДЗ и работа с ней, п.5.2\n");

		// Описание переменных и их инициализация:
		Vehicles S1 = { "Копейка" , "ВАЗ-2101", "Седан" , 2002, 30000 };
		printf("Марка: %25s \nМодель: %24s \nТип кузова: %20s \nГод выпуска: %16d г.\nСтоимость: %14.3lf Рублей\n\n", S1.Marka_car, S1.Model_car, S1.Corpuse, S1.Date_year, S1.Price);

		// Создаем структуру с пустыми заполнениями
		Vehicles S2;
		struct Vehicles S3;

		// Присваивание третьей структуры у первой структуры
		S3 = S1;

		Vehicles* pS;
		pS = &S1;
		pS->Price = 35000;
		Print_Vehicles(S1);

		// Заполнение структуры:
		Vehicles_Fill(&S2);
		Print_Vehicles(S2);

		Vehicles_Input(&S3);
		Print_Vehicles(S3);

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 3:
	{
		/*
		Описать новую структурную переменную и заполнить все ее поля одним из способов представленных выше.
		Создать функцию распечатки своей структуры (Print…).
		Параметр функции структурная переменная (не указатель!).
		Продемонстрировать работу этой функции из главной программы.
		Выполнить пошаговую отладку с заходом в функцию печати.
		Описание функции (описание поместим в файл second.cpp):
		*/

		system("cls");
		printf("  3. Функция Распечатки структуры, п.5.3\n");

		Vehicles S1;

		// Заполнение структуры вручную
		//Structure_Vehicles_Input(&S1);

		// Описание переменных и их инициализация:
		S1 = { "Жигуль" , "ВАЗ-2111", "Седан" , 2012, 50000 };

		// Печать структуры в консольное окно
		Print_Vehicles(S1);

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 4:
	{
		/*
		Описать структуру и заполнить все поля. Создать функцию распечатки своей структуры (Print…).
		Параметр функции указатель на структурную переменную своего типа.
		Описать свою структуру и вызвать функцию печати через указатель.
		Продемонстрировать работу функции из главной программы.
		Использование функции печати через указатель (описание поместим в файл second.cpp):
		*/

		system("cls");
		printf("  4. Функция Распечатки структуры через указатель, п.5.4\n");

		Vehicles S1;

		// Описание переменных и их инициализация:
		S1 = { "Жигуль" , "ВАЗ-2111", "Седан" , 2012, 50000 };

		// Печать на экран структуры через указатели
		Print_Vehicles_Pointer(&S1);

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 5:
	{
		/*
		Описать массив своих структур, выполнить его инициализацию и одновременно
		распечатать массив структур в одном цикле, используя функцию распечатки одной структуры,
		разработанную ранее через указатель.
		*/

		system("cls");
		printf("  5. Массив структур, его инициализация и функция распечатки, п.5.5\n");

		int size;

	RETURN:;

		printf("Введите кол-во структур\n Количество: ");
		scanf_s("%d", &size);

		if (size < 1)
		{
			printf("Ошибка! Размер массива должен больше 0\n");
			goto RETURN;
		}

		Vehicles* ArrS = (Vehicles*)calloc(size, sizeof(Vehicles));

		printf("\n");
		ArrS[0] = { "Нива" , "ВАЗ-2124", "Внедорожник" , 2002, 10000 };
		Print_Vehicles(ArrS[0]);

		for (int i = 0; i < size; i++)
		{
			// Заполнение структуры вручную
			Vehicles_Input(&ArrS[i]);
		}

		printf("Структуры\n\n");

		for (int i = 0; i < size; i++)
		{
			printf("Структура [ %d ]:\n", i + 1);
			Print_Vehicles(ArrS[i]);
		}

		free(ArrS);

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 6:
	{
		/*
		Создать и продемонстрировать работу функции копирования своих структур.
		Исходная структура и структура для копирования передаются в функцию через указатели.
		При копировании структур применить функцию копирования строк.
		Продемонстрировать применение функции копирования структур.
		Распечатать исходные структуры до и после вызова функции копирования.
		*/

		system("cls");
		printf("  6. Функция копирования структур, п.5.6\n");

		Vehicles S1, S2, S3, S4;

		S1 = { "Нива" , "ВАЗ-2124", "Внедорожник" , 2002, 10000 };

		// Присваивание и копирование через квалицифированную ссылку:
		Vehicles_Fill(&S2);

		printf("Первая структура\n");
		Print_Vehicles(S1);

		printf("Вторая структура\n");
		Print_Vehicles(S2);

		// Копируем у структуры 2
		Copy_Vehicles(&S1, &S2);
		Copy_Vehicles(&S3, &S2);
		Copy_Vehicles(&S4, &S2);

		printf("Первая структура\n");
		Print_Vehicles(S1);

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 7:
	{
		/*
		Создать функцию взаимного обмена (Swap…) для двух структур своего варианта.
		В структуре все поля статические (строки – массивы фиксированного размера).
		Использовать функцию копирования структур из предыдущего пункта (у нас CopyStudent).
		Продемонстрировать использование этой функции,
		распечатав две структурные переменные до и после обмена.
		*/
		system("cls");
		printf("  7. Функция обмена (Swap) для структур, п.5.7\n");

		Vehicles S1, S2;

		S1 = { "Нива" , "ВАЗ-2124", "Внедорожник" , 2002, 10000 };

		Vehicles_Fill(&S2);

		printf("Первая структура\n");
		Print_Vehicles(S1);

		printf("Вторая структура\n");
		Print_Vehicles(S2);

		// Вызов функции для обмена структуры
		Swap_Vehicles(&S1, &S2);
		printf("После обмена\n");

		printf("Первая структура\n");
		Print_Vehicles(S1);

		printf("Вторая структура\n");
		Print_Vehicles(S2);

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 8:
	{
		/*
		Повторить раздел перечислений из методических указаний (раздел 3) и литературы.
		Описать перечисление по своему варианту (см. ниже).
		Присвоить своему перечислению имя латинскими буквами, но понятное пользователю.
		Продемонстрировать использование перечисления для разных способов задания констант:
		по умолчанию, с базовым числом и со всеми установленными значениями.
		Описать переменную вашего перечислимого типа и продемонстрировать ее корректное и некорректное
		(недопустимое присваивание) применение и распечатку значений.
		Переменные перечислимого типа являются целыми.
		*/
		// Времена года
		system("cls");
		printf("  8. Использование перечислений по варианту, п.5.8\n");

		int sezon;

		printf("Введите времена года цифрами от 1 до 4: ");
		scanf_s("%d", &sezon);

		//enum Seasons { Winter = 1, Spring, Summer, Autumn };

		switch (sezon)
		{
		case Winter: printf("Зима!\n"); break;
		case Spring: printf("Весна!\n"); break;
		case Summer: printf("Лето!\n"); break;
		case Autumn: printf("Осень!\n"); break;
		default: printf("Нет такого времени года\n");
		}


		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 9:
	{
		/*
		Заполнить числовое поле целого типа вашего массива структур
		(массив создан и инициализирован ранее в п. 5.5).
		Использовать функции rand/srand см. раздел 4 .
		Распечатать заполненный массив своей функцией.
		*/

		system("cls");
		printf("  9. Заполнение числовых полей массива структур случайными данными, п.5.7\n");


		int size;

	RETURN1:;

		printf("Введите кол-во структур\n Количество: ");
		scanf_s("%d", &size);

		if (size < 1)
		{
			printf("Ошибка! Размер массива должен больше 0\n");
			goto RETURN1;
		}

		Vehicles* ArrS = (Vehicles*)calloc(size, sizeof(Vehicles));

		for (int i = 0; i < size; i++)
		{
			// Заполнение структуры вручную
			Vehicles_Fill(&ArrS[i]);
			Vehicles_Fill_Random_DateYear_Price(&ArrS[i]);
		}

		printf("Структуры\n\n");

		for (int i = 0; i < size; i++)
		{
			printf("Структура [ %d ]:\n", i + 1);
			Print_Vehicles(ArrS[i]);
		}

		free(ArrS);


		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	// ДТ 

	case 10:
	{
		/*
		Описать, инициализировать массив своих структурных переменных.
		Отсортировать массив по полю варианта (1-е, 2-е или 3-е) по номеру в структуре.
		Направление сортировки указано в таблице: (В) - возрастание или (У) - убывыание.
		*/
		system("cls");
		printf("  10. Сортировка массива по целому полю, п.7.1\n");
		// 1-е (У) -> Сортировка по алфавитному порядку

		int size;

	RETURN2:;

		printf("Введите размер массив структур (от 2)\n Размер: ");
		scanf_s("%d", &size);

		if (size < 3)
		{
			printf("Ошибка! Размер массив структуры должен больше 2\n");
			goto RETURN2;
		}

		Vehicles* Cars;

		Cars = (Vehicles*)malloc(size * sizeof(Vehicles));

		//Cars[0] = {"Нива" , "ВАЗ-2124", "Внедорожник" , 2002, 10000};
		Cars[0] = { "Niva" , "VAZ-2124", "Off-road" , 2002, 10000 };
		//Print_Vehicles(First_car[0]);

		Vehicles_Fill(&Cars[1]);
		//Print_Vehicles(First_car[1]);

		for (int i = 2; i < size; i++)
		{
			// Заполнение структуры вручную
			Vehicles_Input(&Cars[i]);
		}

		printf("Структуры\n\n");

		for (int i = 0; i < size; i++)
		{
			printf("Структура [ %d ]:\n", i + 1);
			Print_Vehicles(Cars[i]);
		}
		printf("\n");

		printf("Сортировка структуры\n");
		// Сортировка структура по алфавиту по методу пузырьки (УБЫВАНИЕ)
		sorting_bubble_st_alphafit(Cars, size);
		printf("После сортировки структуры\n\n");

		for (int i = 0; i < size; i++)
		{
			printf("Структура [ %d ]:\n", i + 1);
			Print_Vehicles(Cars[i]);
		}
		printf("\n");

		free(Cars);

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 11:
	{
		/*
		Описать двумерный массив структур (два измерения массива) для своего варианта.
		Инициализировать его при описании и распечатать в цикле, оформив вывод оригинально.
		*/
		system("cls");
		printf("  11. Двумерный массив структур, инициализация и распечатка, п.7.2\n");

		int size_row, size_col;

	RETURN3:;

		printf("Введите кол-во длин массив структур\n Количество: ");
		scanf_s("%d", &size_row);

		if (size_row < 1)
		{
			printf("Ошибка! Размер массив структуры должен больше 0\n");
			goto RETURN3;
		}

		printf("Введите кол-во ширин массив структур \n Длина: ");
		scanf_s("%d", &size_col);

		if (size_col < 1)
		{
			printf("Ошибка! Размер массива должен больше 0\n");
			goto RETURN3;
		}

		Vehicles** Mathric_Struct = (Vehicles**)calloc(size_row, sizeof(Vehicles**));
		for (int i = 0; i < size_row; i++)
			Mathric_Struct[i] = (Vehicles*)calloc(1, sizeof(Vehicles));

		// Иницилизация структуры
		Mathric_Struct[0][0] = { "Копейка" , "ВАЗ-2101", "Седан" , 2002, 30000 };
		Print_Vehicles(Mathric_Struct[0][0]);

		// Заполнение структуры вручную 
		for (int i = 0; i < size_row; i++)
			for (int j = 0; j < size_col; j++)
				Vehicles_Input(&Mathric_Struct[i][j]);

		// Печать на экран
		for (int i = 0; i < size_row; i++)
		{
			printf("Структура №%d\n", i + 1);
			for (int j = 0; j < size_col; j++)
			{
				printf("Структура №%d\n", j + 1);
				Print_Vehicles(Mathric_Struct[i][j]);
			}
		}


		free(Mathric_Struct);

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 12:
	{

		system("cls");
		printf("  12. Заполнение данных случайными числами в массиве структур, п.7.3\n");

		Array Mas;

		for (int i = 0; i < 10; i++)
		{
			// Макс 10 и мин 5
			Mas.A[i] = 5 + (rand() % (10 - 5) + 1);
			printf("Mas.A [%d] : %d\n", i, Mas.A[i]);
		}

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 13:
	{

		system("cls");
		printf("  13. Поиск экстремума в массиве структур, его номера и распечатка, п.7.4\n");

		/*
		по итерационному циклу за счет промежуток x1 и x2 выявляем экстремумы функции

		Примечание: экстремумы - это когда значение функции изменяется в другую сторону (возрастания или убывания)
		*/

		float a, b, c, d, x1, x2;
		// Шаг, чем меньше шаг, тем точнее отсчет. По умолчанию стоит 0.5
		//double step = 0.5;
		double step;
		int i = 0;

		printf("Программа для вычисления корней кубического уравнения\n");
		printf("a*x^3 + b*x^2 + c*x + d = 0\n\n");

		printf("Введите а = ");
		scanf_s("%f", &a);
		printf("Введите b = ");
		scanf_s("%f", &b);
		printf("Введите c = ");
		scanf_s("%f", &c);
		printf("Введите d = ");
		scanf_s("%f", &d);

		printf("\n");
		printf("Укажите промежуток x1 = ");
		scanf_s("%f", &x1);
		printf("Укажите промежуток x2 = ");
		scanf_s("%f", &x2);
		printf("\n");
		printf("Укажите значение точности (чем меньше, тем точнее) = ");
		scanf_s("%lf", &step);
		printf("\n");


		double d_x = x1;
		// Размер
		int size = (int)((labs(x1) + labs(x2)) / step);

		//double* arr = (double*)calloc(size, sizeof(double));

		/*
		// Вызвано исключение: нарушение доступа для чтения. this->SIZE было 0xCCCCCCCC.
		// Создаем указатели, которая будет указывать на ту структуру для изменения значений
		Array_Dinamical* p_arr = &arr;

		// Передаем размер массива в структуре, чтобы в структуре устанавливал динамический массив с размером size
		p_arr->SIZE = &size;


		// Создаем указатели, которая будет указывать на ту поля структура для изменения значений
		int Array_Dinamical::* pPole;
		pPole = &Array_Dinamical::SIZE;

		// Создаем структуру
		struct Array_Dinamical arr;

		// Изменяем и устанавливаем значение
		arr.*pPole = size;

		// Для проверки
		printf("size in struct = %d\n", arr.SIZE);

		Array_Dinamical* p_arr = &arr;

		st pst;
		pst.array = (int*)malloc(pst.count * sizeof(int));
		*/

		Array_Dinamical arr;
		Array_Dinamical* p_arr = &arr;

		p_arr->A = (double*)calloc(size, sizeof(double));

		// Итерационый цикл
		while (d_x <= x2)
		{
			// Вызвано исключение: нарушение доступа для записи. arr.A было 0x1110112.
			//arr.A[i] = a * pow(d_x, 3) + b * pow(d_x, 2) + c * d_x + d;
			p_arr->A[i] = a * pow(d_x, 3) + b * pow(d_x, 2) + c * d_x + d;
			printf("d_x = %3.5lf		f[%d] = %3.5lf\n", d_x, i, p_arr->A[i]);

			d_x = d_x + step;
			i++;
		}

		printf("\n");

		arr.index.max = find_x_max_st(&arr, size);
		arr.index.min = find_x_min_st(&arr, size);

		if ((arr.index.max == 0) && (arr.index.min == 0))
			printf("Не существуют экстремумы на этой отрезке\n");
		else if (arr.index.max == 0)
		{
			printf("Не существуют экстремума максимума на этой отрезке\n");
			printf("Точка минимума f[ %d ] = %0.3lf \n", arr.index.min, p_arr->A[arr.index.min]);
		}
		else if (arr.index.min == 0)
		{
			printf("Не существуют экстремума минимума на этой отрезке\n");
			printf("Точка максимума f[ %d ] = %0.3lf \n", arr.index.max, p_arr->A[arr.index.max]);
		}
		else if ((arr.index.max != 0) && (arr.index.min != 0))
		{
			printf("Точка максимума f[ %d ] = %0.3lf \n", arr.index.max + 1, p_arr->A[arr.index.max + 1]);
			printf("Точка минимума f[ %d ] = %0.3lf \n", arr.index.min + 1, p_arr->A[arr.index.min + 1]);
		}

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 14:
	{

		system("cls");
		printf("  14. Сортировка массива структур своего варианта ДЗ по символьному параметру, п.7.5\n");

		int size;

	RETURN4:;

		printf("Введите размер структур (от 2)\n Размер: ");
		scanf_s("%d", &size);

		if (size < 1)
		{
			printf("Ошибка! Размер структуры должен больше 2\n");
			goto RETURN4;
		}

		Vehicles* Cars;

		Cars = (Vehicles*)malloc(size * sizeof(Vehicles));

		for (int i = 0; i < size; i++)
		{
			// Заполнение структуры вручную
			Vehicles_Input(&Cars[i]);
		}

		printf("Структуры\n\n");

		for (int i = 0; i < size; i++)
		{
			printf("Структура [ %d ]:\n", i + 1);
			Print_Vehicles(Cars[i]);
		}
		printf("\n");

		printf("Сортировка структуры\n");
		// Сортировка структура по алфавиту по методу пузырьки (УБЫВАНИЕ)
		sorting_bubble_st_alphafit(Cars, size);
		printf("После сортировки структуры\n\n");

		for (int i = 0; i < size; i++)
		{
			printf("Структура [ %d ]:\n", i + 1);
			Print_Vehicles(Cars[i]);
		}
		printf("\n");

		free(Cars);


		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 15:
	{
		/*Описать и заполнить массив указателей на структуры своего варианта ДЗ.
		Выполнить сортировку данного массива любому по числовому параметру.
		Результат распечатать в цикле.*/
		system("cls");
		printf("  15. Сортировка массива указателей на структуры, п.7.6\n");

		Array MAS;

		int* p_mas = MAS.A;

		// 0 индекс
		*p_mas = 10;

		// 4 индекс
		p_mas[3] = 777;

		for (int i = 0; i < 10; i++)
		{
			p_mas[i] = rand() % 10;
			printf("p_mas [ %d ] : %d\n", i, p_mas[i]);
		}



		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 16:
	{
		/*Создать функцию для динамического создания и случайного заполнения массива структур своего варианта
		ДЗ. Число элементов задается параметром. Хотя бы одно из полей должно быть динамической строкой.
		Динамическая память для нее выделяется в функции. Возврат функции – указатель на массив нужного типа.
		Задать формальные параметры (диапазон чисел) для случайного заполнения.
		Результат выделения распечатать.
		Для строк память должна динамически выделяться.*/
		system("cls");
		printf("  16. Функция для создания и заполнения динамического массива структур, п.7.7\n");

		int size;

		printf("Введите размер массива: ");
		scanf_s("%d", &size);

		Array_Dinamical arr;
		Array_Dinamical* p_arr = &arr;

		// Создаем динамический массив
		p_arr->A = (double*)calloc(size, sizeof(double*));

		// Вызов функции создании динамического массива и заполнение его
		create_dinamical_arr(p_arr->A, size);

		printf("До сортировки\n\n");
		for (int i = 0; i < size; i++)
			printf("A [ %d ] : %0.3lf\n", i, p_arr->A[i]);

		printf("\n");

		printf("После сортировки\n\n");
		sorting_bubble_st_arr_double(p_arr, size);

		for (int i = 0; i < size; i++)
			printf("A [ %d ] : %0.3lf\n", i, p_arr->A[i]);


		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 17:
	{
		/*Создать функцию (FreeStruct) для корректного удаления динамического массива структур
		с динамическими строками. Удаляются и строки и массив.
		Удаление в функции производиться в цикле.*/
		system("cls");
		printf("  17. Функция для корректного удаления динамического массива структур ДЗ, п.7.8\n");

		int size_struct, size_array, size;

		printf("Введите размер структур: ");
		scanf_s("%d", &size_struct);
		printf("Введите размер массива: ");
		scanf_s("%d", &size_array);

		Array_Dinamical arr;
		Array_Dinamical* p_arr = &arr;

		Array_Dinamical* p_str = p_arr;

		// Создаем динамическую структуру
		p_arr = (Array_Dinamical*)calloc(size_struct, sizeof(Array_Dinamical));

		for (int i = 0; i < size_struct; i++)
		{
			// Используем указатели на номер структуры для удобста выделении памяти
			p_str = &p_arr[i];
			// Создаем динамический массив
			// size_array -> количество слов, sizeof(char) в слово хранится 1 байт, т.е 1 буква
			// sizeof(char) * 100 = в слово хранится 100 байтов, т.е 50 букв
			p_str->S = (char*)calloc(size_array, sizeof(char) * 50);

			printf("Структура [ %d ]:\n\n", i + 1);

			for (int j = 0; j < size_array; j++)
			{
				// Слово с длиной 100 байтов (100 букв), включая нулевой символ '\0'
				size = rand() % 50;
				//size = 10;
				// Создаем переменную word с указателем на структуру с j номером массива
				// word будет словом, в котором пополняется случайная буква
				char* word = &p_str->S[j];

				// Генерация случайного набора символа
				for (int k = 0; k < size; k++)
				{
				RETURN_CHAR:;

					// Таблица символов ASCII 0 - 127
					char bukva = (char)(0 + (rand() % (127 - 0)));

					// Проверяем условие, чтобы не попались абзаец и нулевой символ, заверщающий предложение
					if ((bukva == '\n') && (bukva == '\0'))
						goto RETURN_CHAR;

					// Добавляет буквы к слову
					word[k] = word[k] + bukva;
				}
				// Добавляем в конце нули, чтобы завершить слово
				word[strlen(word)] = '\0';

				printf("Слова [ %d ] : %s\n", j, p_str->S);
			}
			printf("\n");
		}

		// Присваиваем все значения в основную стркутуру
		arr = *p_arr;
		// Освобождаем памяти все указатели структуры
		FreeStruct(p_arr);

		/*
		// Очистка структуры и ее содержание
		for (int i = 0; i < size_struct; i++)
		{
			p_str = &p_arr[i];
			for (int j = 0; j < size_array; j++)
			{
				//char* word = &p_str->S[j];
				char* word = p_str->S;

				free(word);

				//free(p_str->S);
			}


			// Освобождается памяти все массивы в i структуре
			//free(d_p_str->S);

			// Освобождается памяти структуры
			//free(d_p_str);
		}
		*/

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 18:
	{
		/*Создать и проверить функцию для своей структуры,
		в которой выделено поле указатель на динамические строки.
		При выполнении функции учитывается то, что строки в структуре могут иметь разную длину.*/
		system("cls");
		printf("  18. Swap для структуры с динамическими строками, п.7.9\n");

		Array_Dinamical arr;

		Array_Dinamical* p_arr = &arr;

		Array_Dinamical* p_str = p_arr;

		for (int i = 0; i < 2; i++)
		{
			// Используем указатели на номер структуры для удобста выделении памяти
			p_str = &p_arr[i];

			// Создаем динамический массив и выделяем им память
			p_str->S = (char*)calloc(1, sizeof(char) * 100);

			// Создаем переменную word с указателем на структуру с 0 номером массива
			// word будет словом, в котором пополняется случайная буква
			char* word = &p_str->S[0];

			printf("Слово №%d : ", i);
			scanf("%s", &p_str->S[0]);

			// Будет храниться в буфер обмена последнее слово
			char* tmp = (char*)calloc(strlen(&p_str->S[0]), sizeof(char));
			strcpy(tmp, &p_str->S[0]);

			//printf("\n");
		}
		printf("До обмена:\n");
		printf("Первое слово %s\n", &arr.S[0]);
		printf("Второе слово %s\n", &p_str->S[0]);

		// Обмен динамической строки
		swap_dinamical_string(&arr.S[0], &p_str->S[0]);

		printf("После обмена:\n");
		printf("Первое слово %s\n", &arr.S[0]);
		printf("Второе слово %s\n", &p_str->S[0]);

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 19:
	{
		/*Создать функцию для ввода одной структуры.*/
		system("cls");
		printf("  19. Функция ввода структуры, п.7.10\n");

		Vehicles Cars;


		// Ввод структуры через квалифицированные ссылки
		Vehicles_Fill(&Cars);
		Print_Vehicles(Cars);

		// или

		// Ввод структуры вручную
		Vehicles_Input(&Cars);
		Print_Vehicles(Cars);

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 20:
	{
		/*Создать функцию для изменения полей одной структуры.
		Новые значения полей задаются параметрами. Все строки статические.*/
		system("cls");
		printf("  20. Функция изменения структуры, п.7.11\n");

		Vehicles Cars;

		// Ввод структуры вручную
		Vehicles_Input(&Cars);
		Print_Vehicles(Cars);

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 21:
	{
		/*Инициализация ручная. Сортировка по одному из полей, которое задано вариантом (номер поля).
		Использовать для этого функцию  Swap для динамических строк.
		На базе своего ва-рианта ДЗ сортировка выполняется по числовому параметру.
		Распечатать массив своей функци-ей.*/
		system("cls");
		printf("  21. Сортировка массива структур, п.7.12\n");

		int size;

		printf("Введите размер массива: ");
		scanf_s("%d", &size);

		Array_Dinamical arr;
		Array_Dinamical* p_arr = &arr;

		p_arr->A = (double*)calloc(size, sizeof(double));

		printf("До сортировки\n\n");
		for (int i = 0; i < size; i++)
		{
			// Max = 50.00; Min = 10.00;
			p_arr->A[i] = 10 + (double)(rand()) / ((double)(RAND_MAX / (50 - (10))));
			printf("A [ %d ] : %0.3lf\n", i, p_arr->A[i]);
		}
		printf("\n");

		printf("После сортировки\n\n");
		sorting_bubble_st_arr_double(p_arr, size);

		for (int i = 0; i < size; i++)
			printf("A [ %d ] : %0.3lf\n", i, p_arr->A[i]);

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 22:
	{
		// Откуда пункт 22? Я по своей невнимательности написал программу, которая создает
		// в динамической структуре динамический массив, в котором содержатся вещественные числа
		// Поэтому пришлось заново написать программу уже с другой типой переменной, а именно, символ, char

		/*Создать функцию (FreeStruct) для корректного удаления динамического массива структур
		с вещественными числами. Удаляются и вещественные числа и массив.
		Удаление в функции производиться в цикле.*/
		system("cls");
		printf("  22. Функция для корректного удаления динамического массива структур ДЗ, п.7.8\n");

		int size_struct, size_array;

		printf("Введите размер структур: ");
		scanf_s("%d", &size_struct);
		printf("Введите размер массива: ");
		scanf_s("%d", &size_array);

		Array_Dinamical arr;
		Array_Dinamical* p_arr = &arr;

		Array_Dinamical* p_str = p_arr;

		// Создаем динамическую структуру
		p_arr = (Array_Dinamical*)calloc(size_struct, sizeof(Array_Dinamical));

		printf("Структуры до удаления\n\n");

		for (int i = 0; i < size_struct; i++)
		{
			// Используем указатели на номер структуры для удобста выделении памяти
			p_str = &p_arr[i];
			// Создаем динамический массив
			p_str->A = (double*)calloc(size_array, sizeof(double));

			//printf("p_str -> p_arr [ %d ] : %d \n", i, *p_str);
			printf("Структура [ %d ]:\n\n", i + 1);

			for (int j = 0; j < size_array; j++)
			{
				p_str->A[j] = 10 + (double)(rand()) / ((double)(RAND_MAX / (50 - (10))));
				//printf("p_str -> A [ %d ] : %0.2lf \n", j, p_str->A[j]);
				printf("A [ %d ] : %0.3lf\n", j, p_str->A[j]);
			}
			printf("\n");
		}

		// Присваиваем все значения в основную стркутуру
		arr = *p_arr;
		// Освобождаем памяти все указатели структуры
		free(p_arr);

		printf("\n");
		system("pause");
		sw = getchar();
		goto MENU;
		break;
	}

	case 0:
	{
		printf("Выход с программы\n\n");

		// После этого пункта выход из программы
		exit(0);
	}

	default:
	{
		printf("Данный символ не опознан. Возврат в меню\n");

		// Сброс буферизации при нажатии ENTER
		sw = getchar();

		system("pause");
		goto MENU;
		break;
	}

	system("PAUSE");
	}
}

